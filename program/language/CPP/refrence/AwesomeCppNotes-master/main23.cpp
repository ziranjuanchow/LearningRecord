
/*******************************************
                         C++ static
    https://www.cnblogs.com/BeyondAnyTime/archive/2012/06/08/2542315.html
                    
        对于一个完整的程序，在内存中的分布情况如下图：　
         【代码区】   【全局数据区】  【堆区】   【栈区】
一般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区。
自动变量一般会随着函数的退出而释放空间，静态数据（即使是函数内部的静态局部变量）也存放在全局数据区。全局数据区的数据并不会因为函数的退出而释放空间。

    一、 面向过程的static关键字
        1. 静态全局变量
            • 该变量在全局数据区分配内存；
            • 未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）；
            • 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；
        2. 静态局部变量
            通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。
            静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。
            静态局部变量有以下特点：
            • 该变量在全局数据区分配内存；
            • 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
            • 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；
            • 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；
        3. 静态函数
            • 在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用
            • 其它文件中可以定义相同名字的函数，不会发生冲突

    二、 面向对象的static关键字
        1. 静态数据成员
            • 对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。也就是说，静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；
            • 静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。在Example 5中，语句int Myclass::Sum=0;是定义静态数据成员；
            • 静态数据成员和普通数据成员一样遵从public,protected,private访问规则；
            • 因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；
            • 静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：
            ＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞
            • 类的静态数据成员有两种访问形式：
            ＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞
        2. 静态成员函数
            • 出现在类体外的函数定义不能指定关键字static；
            • 静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；
            • 非静态成员函数可以任意地访问静态成员函数和静态数据成员；
            • 静态成员函数不能访问非静态成员函数和非静态数据成员；
            • 由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；
            • 调用静态成员函数，可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式：
            ＜类名＞::＜静态成员函数名＞（＜参数表＞） 调用类的静态成员函数。
**********************************************/
#include <iostream>
using namespace std;
class Myclass
{
public:
    Myclass(int a,int b,int c);
    void GetSum();
private:
    int a,b,c;
    static int Sum;//声明静态数据成员
};
int Myclass::Sum=0;//定义并初始化静态数据成员

Myclass::Myclass(int a,int b,int c)
{
    this->a=a;
    this->b=b;
    this->c=c;
    Sum+=a+b+c;
}

void Myclass::GetSum()
{
    cout<<"Sum="<<Sum<<endl;
}

int main()
{
    Myclass M(1,2,3);
    M.GetSum();
    Myclass N(4,5,6);
    N.GetSum();
    M.GetSum();

    return 0;
}




